<div class="lessonstep">In 1970, British mathematician John Horton Conway developed a cellular automaton known as <a href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life" target="_blank">"The Game of Life"</a>.  Dyalog's John Scholes put together a video exploration of an <a href="http://www.youtube.com/watch?v=a9xAKttWgP4&amp;fmt=18" target="_blank">APL implementation of the Game of Life</a>.<br/><br/>This tutorial steps through much the same path that John took in his presentation allowing you to investigate each individual step.<br/><br/>First we'll build the initial board which is a 3 by 3 bit pattern centered in a 5 by 7 board.</div>

<div class="lessonexec">⍳ 9 ⍝ generate the first 9 integers</div>

<div class="lessonstep">Many APL functions have mnemonic or visual clues to their meaning.  In this case <a title="Monadic means the function only has one argument">monadic</a> iota <span class="APL">⍳</span>, the Greek letter for "i", implements  the <b>i</b>ndex generator function.</div>

<div class="lessonexec">3 3 ⍴ ⍳ 9</div>

<div class="lessonstep"><a title="Dyadic means the function has two arguments">Dyadic</a> rho <span class="APL">⍴</span> implements the <b>r</b>eshape function.  As APL executes from right to left, <span class="APL">3 3 ⍴ ⍳ 9</span> reshapes <span class="APL">⍳ 9</span> into a 3 by 3 matrix.</div>

<div class="lessonexec">(3 3 ⍴ ⍳ 9) ∊ 2 3 4 5 8</div>

<div class="lessonstep">Dyadic epsilon <span class="APL">∊</span> implements the "<b>e</b>lement of" function.  This generates the starting bit pattern.  Now we need to position it within our board.  But first let's save the pattern in a variable named <span class="APL">r</span></div>

<div class="lessonexec">r ← (3 3 ⍴ ⍳ 9) ∊ 2 3 4 5 8</div>

<div class="lessonstep">You can display <span class="APL">r</span> merely by entering its name.</div>

<div class="lessonexec">r</div>

<div class="lessonstep">Now that we have our starting pattern, we'll center it in a 5 by 7 board.  The first step is to use the take function <span class="APL">↑</span> to pad out the pattern to our desired size.</div>

<div class="lessonexec">5 7 ↑ r</div>

<div class="lessonstep">The next step is to column-center the pattern...</div>

<div class="lessonexec">¯2 ⌽ 5 7 ↑ r</div>

<div class="lessonstep">The high minus <span class="APL">¯</span> is used to denote a negative number.  The symbol <span class="APL">⌽</span> rotates along the last axis, which is the columns in an array of <a title="Rank is just another term for the number of dimensions an array has.  A table is a rank 2 array.">rank</a> 2 greater.<br/><br/>  Next we row-center the pattern using the <span class="APL">⊖</span> function which rotates along the first axis.</div>

<div class="lessonexec">¯1 ⊖ ¯2 ⌽ 5 7 ↑ r</div>

<div class="lessonstep">We now assign the board to the variable <span class="APL">R</span></div>

<div class="lessonexec">R ← ¯1 ⊖ ¯2 ⌽ 5 7 ↑ r</div>

<div class="lessonstep">The rules for the Game of Life dictate which cells live based on their number of live neighbors.  So, our next job is to count the neighbors and we'll do this by shifting the board by 1 unit in each direction and summing the result...</div>

<div class="lessonexec">1 0 ¯1 ⌽¨ ⊂R</div>

<div class="lessonstep">First, the enclose <span class="APL">⊂</span> function takes any array and turns it into a rank 0 array, also known as a scalar.  Many APL functions support "scalar extension" which distributes the scalar and applies the function to each of the items in the other argument.  In this case, we're using <span class="APL">⌽</span> again to perform column shifts.  The "each" <a title="An operator takes function(s) as arguments and returns a new function">operator</a> <span class="APL">¨</span> applies <span class="APL">⌽</span> between each element of the left argument <span class="APL">1 0 ¯1</span> and <span class="APL">⊂R</span></div>

<div class="lessonexec">1 0 ¯1 ∘.⊖ 1 0 ¯1 ⌽¨ ⊂R</div>

<div class="lessonstep">Now we've used the outer product operator <span class="APL">∘.</span> which applies its function, in this case <span class="APL">⊖</span>, between all combinations of the left and right arguments.  So, we wind up with a 3 by 3 array of with our original board in the center and all of the "1-rotations" surrounding.<br/><br/>We can now add up the neighbors. </div>

<div class="lessonexec">+/ 1 0 ¯1 ∘.⊖ 1 0 ¯1 ⌽¨ ⊂R</div>

<div class="lessonstep"><span class="APL">+/</span> sums along the last axis.  <span class="APL">/</span> is another operator, called reduce, and applies its function along the last axis of its data.  Notice that <span class="APL">/</span> "reduces" the rank of an array, in this case giving a result of a vector from a 3 by 3 matrix.<br/><br/>Next we sum the vector...</div>

<div class="lessonexec">+/ +/ 1 0 ¯1 ∘.⊖ 1 0 ¯1 ⌽¨ ⊂R</div>

<div class="lessonstep">And this gives us a neighbor count of our original matrix.<br/><br/>Now, a cell is "live" (has a 1) in the next generation if either its neighbor count is 3, or its neighbor count is 4 AND the cell is alive in the current generation.  So, we can find where the neighbor counts are 3 and 4...</div>

<div class="lessonexec">3 4 = +/ +/ 1 0 ¯1 ∘.⊖ 1 0 ¯1 ⌽¨ ⊂R</div>

<div class="lessonstep">And then take any 3, and 4's where there's a 1 in the current generation...</div>

<div class="lessonexec">1 R ∧ 3 4 = +/ +/ 1 0 ¯1 ∘.⊖ 1 0 ¯1 ⌽¨ ⊂R</div>

<div class="lessonstep">Since both of these matrices contribute to the next generation, we can use reduce again, this time using the <span class="APL">∨.∧</span> inner product and disclosing the result using <span class="APL">⊃</span> to make it a simple matrix.</div>

<div class="lessonexec">⊃1 R ∨.∧ 3 4 = +/ +/ 1 0 ¯1 ∘.⊖ 1 0 ¯1 ⌽¨ ⊂R</div>

<div class="lessonstep">Now we've built an expression which produces the next generation for any boolean matrix R.  Let's turn this into a function by enclosing it in curly braces <span class="APL">{}</span> and using the formal paramter <span class="APL">⍵</span> in place of <span class="APL">R</span>.  We'll call this function <span class="APL">life</span>.</div>

<div class="lessonexec">life←{⊃1 ⍵ ∨.∧ 3 4 = +/ +/ 1 0 ¯1 ∘.⊖ 1 0 ¯1 ⌽¨ ⊂⍵}</div>
<div class="lessonexec">R (life R) (life life R)</div>

<div class="lessonstep">Displays the first 3 generations for <span class="APL">R</span>.<br/><br/>Now, we can generalize that by writing a function <span class="APL">gen</span> which uses the power operator <span class="APL">⍣</span> to apply <span class="APL">life</span> to the power of the left argument to the right argument.</div>

<div class="lessonexec">gen←{(life⍣⍵)⍺}</div>
<div class="lessonexec">R∘gen¨ ⍳4</div>

<div class="lessonstep">Displays the next 4 generations for R by binding <span class="APL">R</span> with <span class="APL">gen</span> using <span class="APL">∘</span> and applying it with each of <span class="APL">⍳4</span>.<br/><br/>Thank you for your interest in this tutorial; we hope you enjoyed it!</div>


