<div class="lessonstep">
Let's begin by developing a "contention map", 
which shows, for each cell in an <span class="APL">⍵×⍵</span> Sudoku puzzle, 
those cells that occupy the same row, column or box:
</div>

<div class="lessonexec">⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ Contention Map</div>
<div class="lessonexec">3 3⍴⍳3×3                            ⍝ matrix of box numbers</div>

<div class="lessonstep">
If this expression is not clear, use up-cursor to 
recall, edit and resubmit <i>part</i> of it.
</div>

<div class="lessonstep">
APL functions apply to everything to their right, 
so you can experiment by removing functions from 
the left of any expression before continuing with 
the script.
</div>

<div class="lessonexec">3/3 3⍴⍳3×3                          ⍝ 3-replicated (/) along rows</div>
<div class="lessonexec">3⌿3/3 3⍴⍳3×3                        ⍝ 3-replicated (⌿) down columns</div>

<div class="lessonstep">
Based on the above, the following function generates this matrix of 
box numbers for boxes of shape <span class="APL">⍵ ⍵</span>:
</div>

<div class="lessonexec">box ← {⍵⌿⍵/⍵ ⍵⍴⍳⍵×⍵}                ⍝ fn: box numbers</div>
<div class="lessonexec">box 3                               ⍝ 3×3 boxes for 9×9 puzzle</div>

<div class="lessonstep">
We'll start with a smaller, <span class="APL">4×4</span> Sudoku:
</div>

<div class="lessonexec">box 2                               ⍝ 2×2 boxes for 4×4 puzzle</div>

<div class="lessonstep">
Primitive function (<span class="APL">⍳</span>) generates an <span class="APL">⍵</span>-array of <b>indices</b>. 
For a matrix, each 2-vector is a row and column number:
</div>

<div class="lessonexec">⍳ 4 4                               ⍝ row and column numbers</div>

<div class="lessonstep">
Primitive operator <b>each</b> (<span class="APL">¨</span>) applies its operand 
function between corresponding items of its argument
arrays.
</div>

<div class="lessonstep">
<b>Catenating</b> (<span class="APL">,</span>) each row-col vector with its box number 
produces a matrix of row-col-box triples:
</div>

<div class="lessonexec">(⍳4 4) ,¨ box 2                     ⍝ row, column and box numbers</div>

<div class="lessonstep">
For a square Sudoku puzzle, the box size is the square-root of the puzzle size. 
</div>

<div class="lessonstep">
In APL, the square-root of <span class="APL">⍵</span> is expressed as <span class="APL">⍵</span> to the <b>power</b> (<span class="APL">*</span>) one-half (<span class="APL">÷2</span>):
</div>

<div class="lessonexec">25 49 * ÷2                          ⍝ to the power reciprocal 2</div>

<div class="lessonstep">
... leading to the following function in which <span class="APL">⊃⍵*÷2</span> means the 
<b>first</b> (<span class="APL">⊃</span>) item of the square-root of the right argument (<span class="APL">⍵</span>):
</div>

<div class="lessonexec">rcb ← {(⍳⍵),¨box⊃⍵*÷2}              ⍝ fn: row-col-box numbers</div>
<div class="lessonexec">rcb 4 4                             ⍝ ... for a 4×4 sudoku puzzle</div>

<div class="lessonstep">
Contention occurs between cells that contain 
corresponding row, column or box numbers.
</div>

<div class="lessonstep">
Here are the cells that share a row, column or box with the cell (<span class="APL">⊂</span>) in the second row, second column:
</div>

<div class="lessonexec">(rcb 4 4) = ⊂2 2 1                  ⍝ cells that share row-col-box with 2 2</div>

<div class="lessonstep">
<b>Each</b> (<span class="APL">¨</span>) vector in the above, of which 1 is a <b>member</b> (<span class="APL">∊</span>), 
represents a row, column or box contention:
</div>

<div class="lessonexec">1 ∊¨ (rcb 4 4)=⊂2 2 1               ⍝ cells in contention with cell at 2 2</div>

<div class="lessonstep">
<b>Outer-product</b> (<span class="APL">∘.</span>) produces a <b>rank 4</b> (<span class="APL">4×4×4×4</span>) array of all comparisons. As the leading axes of this 256-item array are displayed down the page, it is rather long:
</div>

<div class="lessonexec">1 ∊¨ (rcb 4 4) ∘.= rcb 4 4          ⍝ complete contention array</div>

<div class="lessonstep">
<b>Enclosing</b> (<span class="APL">⊂</span>) the first two <b>axes</b> <span class="APL">[⍳2]</span> gives us a <span class="APL">4x4</span> map of <span class="APL">4×4</span> contention matrices.
</div>

<div class="lessonexec">⊂[⍳2] 1 ∊¨ (rcb 4 4) ∘.= rcb 4 4    ⍝ map of contention matrices</div>

<div class="lessonstep">
Abstracting this as a functon of <b>rcb 4 4</b>:
</div>

<div class="lessonexec">{⊂[⍳2] 1∊¨ ⍵∘.=⍵} rcb 4 4           ⍝ contention map</div>

<div class="lessonstep">
and naming the function:
</div>

<div class="lessonexec">cmap ← {⊂[⍳2] 1∊¨ ⍵∘.=⍵}            ⍝ fn: contention map for ⍵-puzzle</div>

<div class="lessonexec">cmap rcb 4 4                        ⍝ contention matrices for 4 4 puzzle</div>

<div class="lessonstep">
Now let's turn our attention to searching for a solution. We use a <b>breadth-first search</b> technique:
</div>

<div class="lessonexec">⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ Breadth-first search</div>

<div class="lessonstep">
Here is a small Sudoku puzzle to be solved:
</div>

<div class="lessonexec">⊢s44 ← 4 4⍴ 0 0 0 0  0 0 2 1  3 0 0 4  0 0 0 0      ⍝ 4×4 Sudoku puzzle</div>

<div class="lessonstep">
The <b>shape</b> (<span class="APL">⍴</span>) of <b>s44</b> is the vector 4 4:
</div>

<div class="lessonexec">⍴ s44                               ⍝ shape of matrix s44</div>

<div class="lessonstep">
Primitive <b>index</b> function (<span class="APL">⌷</span>) selects item(s) from an array. Starting (say) at row 1, column 1:
</div>

<div class="lessonexec">⊃1 1⌷cmap rcb ⍴s44                  ⍝ contention for cell at 1 1</div>

<div class="lessonstep">
The <b>product</b> (×) of this matrix with the 
current state shows which numbers may <i>not</i> 
be placed at 1 1:
</div>

<div class="lessonexec">s44 × ⊃1 1⌷cmap rcb ⍴s44            ⍝ number(s) excluded from posn 1 1</div>

<div class="lessonstep">
<b>Excluding</b> (<span class="APL">~</span>) these numbers (just the number 3 in this case) 
from all possible numbers (<span class="APL">⍳4</span>) reveals which 
numbers are still available for placing at 1 1:
</div>

<div class="lessonexec">(⍳4) ~ s44×⊃1 1⌷cmap rcb ⍴s44       ⍝ plays still available at 1 1</div>

<div class="lessonstep">
with function:
</div>

<div class="lessonexec">avl ← {(⍳⊃⍴⍵) ~ ⍵×⊃⍺⌷cmap rcb ⍴⍵}   ⍝ fn: available plays at ⍺ for state ⍵</div>
<div class="lessonexec">1 1 avl s44                         ⍝ available plays at 1 1 in s44</div>

<div class="lessonstep">
We need a way to place a given number at a particular position in a given state matrix.
</div> 

<div class="lessonstep">
As this operation requires three arguments (number position state), 
it is convenient to code it as an <i>operator</i> with 
<span class="APL">⍺</span>-number <span class="APL">⍺⍺</span>-posn <span class="APL">⍵</span>-state.
</div>

<div class="lessonstep">
We can place the number in a given position with 
primitive function <b>take</b> (<span class="APL">↑</span>):
</div>

<div class="lessonexec">2 3↑99                              ⍝ 99 extended downwards and rightwards</div>
<div class="lessonexec">¯2 ¯3↑99                            ⍝ 99 extended upwards and leftwards</div>
<div class="lessonexec">4 4↑¯3 ¯3↑99                        ⍝ 99 at 3 3 in empty 4 4 grid</div>

<div class="lessonstep">
... and adding the current state:
</div>

<div class="lessonexec">s44 + 4 4↑¯3 ¯3↑99                  ⍝ 99 at 3 3 in s44</div>

<div class="lessonstep">
... giving us this "merge" operator:
</div>

<div class="lessonexec">at ← {⍵+(⍴⍵)↑(-⍺⍺)↑⍺}               ⍝ op: ⍺ at ⍺⍺ in ⍵</div>
<div class="lessonexec">99 (3 3 at) s44                     ⍝ 99 at 3 3 in s44</div>

<div class="lessonstep">
Now, merging <b>each</b> (<span class="APL">¨</span>) available state:
</div>

<div class="lessonexec">1 2 4 (1 1 at)¨ ⊂s44                ⍝ next states of s44 at 1 1</div>

<div class="lessonstep">
Using our <b>avl</b> function to generate the vector of avaliable plays:
</div>

<div class="lessonexec">(1 1 avl s44) (1 1 at)¨ ⊂s44        ⍝ next states of s44 at 1 1</div>

<div class="lessonstep">
... suggesting this function for a vector of available states:
</div>

<div class="lessonexec">nxt ← {(⍺ avl ⍵)(⍺ at)¨⊂⍵}          ⍝ fn: next states of ⍵ at ⍺</div>

<div class="lessonexec">1 1 nxt s44                         ⍝ next states of s44 at 1 1</div>

<div class="lessonstep">
For the <i>following</i> move, we find <i>each</i> possible next state for 
<i>each</i> of these states, choosing a second cell at
which to play.</div>

<div class="lessonstep">
In this way, we start to explore the <i>tree</i> of possibilities, one level at a time. 
</div>

<div class="lessonstep">
Let's continue from position 1 2. Notice that we bind (<span class="APL">∘</span>) 
left argument 1 2 to function <b>nxt</b>, so that the <i>whole</i> of the vector 
constitutes the left argument for each (<span class="APL">¨</span>) application.
</div>

<div class="lessonexec">1 2∘nxt¨ 1 1 nxt s44                ⍝ two levels of tree-search</div>

<div class="lessonstep">
The primitive <b>reduction</b> operator (<span class="APL">/</span>), applied to a vector, 
has the effect of placing its left operand function between each item of its right argument, 
to produce a scalar result. 
</div>

<div class="lessonstep">
We can join the sub-vectors with a catenate (<span class="APL">,</span>) 
reduction (<span class="APL">/</span>) of the vector of vectors and disclosing 
(<span class="APL">⊃</span>) the resulting scalar:
</div>

<div class="lessonexec">⊃,/ 1 2∘nxt¨ 1 1 nxt s44            ⍝ two levels of tree-search</div>

<div class="lessonstep">
In order that the initial state is not a special case, 
it helps to <i>start</i> with a 1-vector by <b>ravel</b>ling (<span class="APL">,</span>) 
the <b>enclose</b> (<span class="APL">⊂</span>) of the puzzle matrix:
</div>

<div class="lessonexec">⊃,/1 2∘nxt¨ ⊃,/1 1∘nxt¨ ,⊂s44       ⍝ 2-level search</div>

<div class="lessonstep">
Continuing from position 2 1:
</div>

<div class="lessonexec">⊃,/2 1∘nxt¨ ⊃,/1 2∘nxt¨ ⊃,/1 1∘nxt¨ ,⊂s44    ⍝ 3-level search</div>

<div class="lessonstep">
Next, we extract the positions 2 1, 1 2 and 1 1 as left argument 
(<span class="APL">⍺</span>) to a containing function:
</div>

<div class="lessonstep">
For example: <span class="APL">⊃,/1 2∘nxt¨...</span><br/>
becomes: <span class="APL">1 2{⊃,/⍺∘nxt¨⍵}...</span>
</div>

<div class="lessonexec">nxtv ← {⊃,/⍺∘nxt¨ ⍵}                ⍝ fn: next state vector</div>

<div class="lessonexec">2 1 nxtv 1 2 nxtv 1 1 nxtv ,⊂s44    ⍝ 3-level search</div>

<div class="lessonstep">
"Factoring out" the <b>nxtv</b> function as a <b>reduction</b> (<span class="APL">/</span>), we recode the above 3-level search as:
</div>

<div class="lessonexec">⊃nxtv/ (2 1)(1 2)(1 1)(,⊂s44)       ⍝ 3-level search</div>

<div class="lessonstep">
Choosing cell (1 3) for our next step:
</div>

<div class="lessonexec">⊃nxtv/ (1 3)(2 1)(1 2)(1 1)(,⊂s44)  ⍝ 4-level search</div>

<div class="lessonstep">
The <i>order</i> of selecting the cells for the search is unimportant. Let's continue from (4 2):
</div>

<div class="lessonexec">⊃nxtv/ (4 2)(1 3)(2 1)(1 2)(1 1)(,⊂s44)           ⍝ 5-level search</div>

<div class="lessonstep">... (3 2) ...</div>

<div class="lessonexec">⊃nxtv/ (3 2)(4 2)(1 3)(2 1)(1 2)(1 1)(,⊂s44)      ⍝ 6-level search</div>

<div class="lessonstep">... and (1 4):</div>

<div class="lessonexec">⊃nxtv/ (1 4)(3 2)(4 2)(1 3)(2 1)(1 2)(1 1)(,⊂s44) ⍝ 7-level search</div>

<div class="lessonstep">
You might like to take a moment to find the complete solution by extending the above list, 
one item at a time, using the remaining empty cell coordinates:<br/>
(4 4) (4 3) (2 2) (3 3) (4 1).</div>

<div class="lessonstep">
For a complete search, we just need to supply our 
reduction with a vector of the positions of <i>all</i> empty cells:
</div>

<div class="lessonstep">
Here is the matrix of all cell positions:
</div>

<div class="lessonexec">⍳⍴ s44                              ⍝ matrix of positions</div>

<div class="lessonstep">
of which, these are the empty ones:
</div>

<div class="lessonexec">s44=0                               ⍝ 1 → empty cell</div>

<div class="lessonstep">
Primitive function <b>ravel</b> (<span class="APL">,</span>) returns a <i>vector</i> of the items of its argument array:
</div>

<div class="lessonexec">, ⍳⍴ s44                            ⍝ vector of positions</div>

<div class="lessonexec">, s44=0                             ⍝ vector of empties</div>

<div class="lessonstep">
<b>Replicate</b> (<span class="APL">/</span>) selects empty cells:
</div>

<div class="lessonexec">(,s44=0)/,⍳⍴s44                     ⍝ positions of empty cells</div>

<div class="lessonstep">giving function:</div>

<div class="lessonexec">emt ← {(,⍵=0)/,⍳⍴⍵}                 ⍝ fn: empty cell positions in state ⍵</div>
<div class="lessonexec">emt s44                             ⍝ empty cell positions in s44</div>

<div class="lessonstep">
We can now find a vector of complete states. 
In general, there may be many solutions although 
published Sudoku puzzles typically have only one.
</div>

<div class="lessonexec">⊃nxtv/(emt s44),⊂,⊂s44              ⍝ vector of all solutions.</div>

<div class="lessonstep">
Abstracting this as a function of the puzzle matrix s44:
</div>

<div class="lessonexec">svec ← {⊃nxtv/(emt ⍵),⊂,⊂⍵}         ⍝ fn: solution vector</div>
<div class="lessonexec">svec s44                            ⍝ solution(s) for s44</div>

<div class="lessonstep">
The following little function nests the <i>boxes</i> of a Sudoku state. 
A <span class="APL">9×9</span> puzzle will appear as a <span class="APL">3×3</span> matrix of <span class="APL">3×3</span> boxes: 
It is left as an "exercise for the student" to figure out how this works.
</div>

<div class="lessonexec">sfmt←{⊂[3 4]1 3 2 4⍉(2/(⍴⍵)*÷2)⍴⍵}  ⍝ pleasing format</div>
<div class="lessonexec">sfmt s44                            ⍝ initial state and</div>
<div class="lessonexec">sfmt ⊃svec s44                      ⍝ ... first (⊃) solution</div>

<div class="lessonstep">
The coding of <b>svec</b> is rather inefficient because it re-calculates <b>cmap rcb</b> at each step:
</div>

<div class="lessonexec">svec                                ⍝ svec calls nxtv for each free cell,</div>
<div class="lessonexec">nxtv                                ⍝ nxtv calls nxt for each state,</div>
<div class="lessonexec">nxt                                 ⍝ nxt calls avl and</div>
<div class="lessonexec">avl                                 ⍝ avl calls cmap rcb ⍴⍵.</div>

<div class="lessonstep">
We can arrange to calculate <b><span class="APL">(cmap rcb ⍴⍵)</span></b> only once and  
passing it as an additional operand from <b>svec</b> to <b>nxtv</b> to <b>nxt</b> to <b>avl</b>.
</div>

<div class="lessonstep">
We do this by making <b>avl</b>, <b>nxt</b> and <b>nxtv</b> into <i>operators</i>, and 
receiving additional parameter <b><span class="APL">(cmap rcb ⍴⍵)</span></b> as operand <span class="APL">⍺⍺</span>. 
Compare these re-codings with the original versions:
</div>

<div class="lessonexec">avl←{(⍳⊃⍴⍵)~⍵×⊃⍺⌷⍺⍺}                ⍝ op avl: receives (cmap rcb ⍴⍵) as ⍺⍺ from</div>
<div class="lessonexec">nxt←{(⍺(⍺⍺ avl)⍵)(⍺ at)¨⊂⍵}         ⍝ op nxt: receives (cmap rcb ⍴⍵) as ⍺⍺ from</div>
<div class="lessonexec">nxtv←{⊃,/⍺∘(⍺⍺ nxt)¨⍵}              ⍝ op nxtv: receives (cmap rcb ⍴⍵) as ⍺⍺ from</div>
<div class="lessonexec">svec←{⊃(⍺⍺ ⍴⍵)nxtv/(emt ⍵),⊂⊂⍵}     ⍝ op svec: receives (cmap∘rcb) as operand ⍺⍺.</div>

<div class="lessonstep">
<b>Bind</b>ing (<span class="APL">∘</span>) <b>cmap</b> with <b>rcb</b> as a function operand to <b>svec</b>:
</div>
<div class="lessonexec">sfmt ⊃ cmap∘rcb svec s44            ⍝ ... first (⊃) solution</div>

<div class="lessonstep">
Now we're in a position to try a larger puzzle.
</div>

<div class="lessonstep">
The following sequence specifies each row, starting with a 9<span class="APL">×</span>9 matrix of zeros:
</div>

<div class="lessonexec">s99 ← 9 9⍴0                         ⍝ input of 9×9 puzzle ...</div>
<div class="lessonexec">s99[1;] ← 0 0 1 6 9 0 5 0 0         ⍝ 1st row</div>
<div class="lessonexec">s99[2;] ← 4 0 0 2 7 0 0 0 1         ⍝ 2nd row</div>
<div class="lessonexec">s99[3;] ← 0 7 0 0 0 0 0 9 0         ⍝ 3rd row</div>
<div class="lessonexec">s99[4;] ← 0 0 0 0 0 0 0 3 0         ⍝ 4th row</div>
<div class="lessonexec">s99[5;] ← 0 0 0 4 3 0 0 0 7         ⍝ 5th row</div>
<div class="lessonexec">s99[6;] ← 0 0 0 7 8 0 6 0 0         ⍝ 6th row</div>
<div class="lessonexec">s99[7;] ← 0 0 6 0 0 0 8 0 5         ⍝ 7th row</div>
<div class="lessonexec">s99[8;] ← 0 2 0 1 4 0 0 6 0         ⍝ 8th row</div>
<div class="lessonexec">s99[9;] ← 0 1 0 3 5 0 0 4 0         ⍝ 9th row</div>

<div class="lessonstep">Display of initial state of <span class="APL">9×9</span> puzzle:</div>

<div class="lessonexec">sfmt s99                            ⍝ 9×9 sudoku puzzle</div>

<div class="lessonstep">
Naming a function for the format of the first (<span class="APL">⊃</span>) solution:
</div>

<div class="lessonexec">sudoku ← {sfmt⊃cmap∘rcb svec ⍵}     ⍝ Sudoku solver</div>
<div class="lessonexec">sudoku s44                          ⍝ first solution of smaller puzzle.</div>
<div class="lessonexec">sudoku s99                          ⍝ first solution of larger puzzle</div>

<div class="lessonstep"><b>
A Generalisation
</b></div>

<div class="lessonstep">
APL makes it easy to extend functions to arrays of higher rank.
</div>

<div class="lessonstep">
To demonstrate this, let's convert our code to solve a 3D variant of Sudoku.
</div>

<div class="lessonexec">⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ 3D Sudoku</div>

<div class="lessonexec">s333 ← 3 3 3⍴0                      ⍝ input of 3×3×3 puzzle</div>
<div class="lessonexec">s333[1;;] ← 3 3 ⍴  0 0 0  8 1 0  0 0 2   ⍝ 1st plane</div>
<div class="lessonexec">s333[2;;] ← 3 3 ⍴  0 6 0  0 7 0  9 0 4   ⍝ 2nd plane</div>
<div class="lessonexec">s333[3;;] ← 3 3 ⍴  5 0 0  0 0 3  0 0 0   ⍝ 3rd plane</div>
<div class="lessonexec">s333                                ⍝ 3D Sudoku puzzle</div>

<div class="lessonstep">
We choose slightly different contention conditions: 
there are no "boxes" but numbers must not be repeated in any of the nine x, y, or z planes.
</div>

<div class="lessonstep">
First, we generalise our <b>cmap</b> function: 
</div>

<div class="lessonexec">cmap                                ⍝ 2D-specific cmap</div>

<div class="lessonstep">
to <b>enclose</b> (<span class="APL">⊂</span>) an <i>appropriate</i> number of <b>axes</b> [...].
</div>

<div class="lessonstep">
which is the rank (<span class="APL">⍴⍴</span> the shape of the shape) of the argument array: 
</div>

<div class="lessonexec">cmap ← {⊂[⍳⍴⍴⍵]1∊¨⍵∘.=⍵}            ⍝ rank-invariant cmap</div>

<div class="lessonstep">
Then, using primitive function (<span class="APL">⍳</span>) in place of the <b>rcb</b> function, 
as there are no boxes:
</div>

<div class="lessonexec">sudoku3D ← {⊃cmap∘⍳ svec ⍵}         ⍝ 3D Sudoku solver</div>

<div class="lessonstep">
Finally, we must generalise <b>avl</b> to return available numbers for a <i>subarray</i>.
</div>

<div class="lessonstep">
For 2D Sudoku this will continue to be the numbers for a row or column vector 
and for the 3D version it will be those for a whole plane:
</div>

<div class="lessonexec">avl                                 ⍝ 2D-specific avl</div>

<div class="lessonexec">avl ← {(⍳×/1↓⍴⍵)~⍵×⊃⍺⌷⍺⍺}           ⍝ rank-invariant avl</div>

<div class="lessonexec">  1 1 ((cmap rcb ⍴s99 )avl)  s99    ⍝ 2D plays at 1 1 for s99</div>

<div class="lessonexec">1 1 1 ((cmap ⍳   ⍴s333)avl) s333    ⍝ 3D plays at 1 1 1 for s333</div>

<div class="lessonstep">
Our 2D Sudoku solver continues to work as before:
</div>

<div class="lessonexec">sudoku s99                          ⍝ 2D solution</div>

<div class="lessonstep">
and our 3D solver solves the 3D puzzle s333:
</div>

<div class="lessonexec">sudoku3D s333                       ⍝ 3D solution</div>

<div class="lessonstep">
Notice how few changes were needed to generalise our program for a higher dimensional puzzle.
</div>

<div class="lessonstep">
<b>Conclusion</b>
</div>

<div class="lessonstep">
There are many ways to solve Sudoku. The method used here illustrates a <i>Pure Functional Programming</i> approach.
</div>

<div class="lessonstep">
The code we have developed consists only of the application of functions and operators to their arguments and operands. In particular, it contains:
</div>

<div class="lessonstep">No explicit representation of state (no variables).</div>

<div class="lessonstep">No explicit control structures (no conditionals, loops, etc).</div>

<div class="lessonexec">]defs sudoku -t</div>

<div class="lessonstep">
For alternative codings of Sudoku in APL, see 
<a href="http://dfns.dyalog.com/n_sudoku.htm" target="_blank">http://dfns.dyalog.com/n_sudoku.htm</a>
</div>

<div class="lessonstep">
<b>Credits:</b><br/>
Algorithm:   <a href="http://www.kparc.com/examples/game.k" target="_blank">Arthur Whitney</a><br/>
Inspiration: <a href="http://www.jsoftware.com/papers/nqueens.htm" target="_blank">Roger Hui</a>
</div>

<div class="lessonstep">
That's All Folks! Returning to lessons ...
</div>

